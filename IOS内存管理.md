# IOS内存管理

## IOS中内存分为五个区域：
 1、栈：存储局部变量，当其作用域执行完毕后，就会被系统立即回收；</br>
 2、堆：存储OC对象，手动申请的字节空间，需要调用free来释放；</br>
 3、BBS段：未初始化的全局变量与静态变量，一旦初始化就会从BBS段中回收掉，转存到数据段中；</br>
 4、数据段：存储已经初始化的全局变量与静态变量，以及常量数据，知道程序结束时才会被立即回收；</br>
 5、代码段：代码，直到结束程序时才会被立即收回

## OC中堆区存储对象的特点:
* 除了堆区，其他区域中存储的数据，都是系统自动释放的；
* 堆区中的OC对象，是不会自动释放的，如果不主动释放，那么将在程序结束的时候才去释放

#### 无论在MRC还是ARC情况下，Objective-C采用的是引用计数式的内存管理方式，这一方式的特点：

* 自己生成的对象，自己持有。例如：NSObject * __strong obj = [[NSObject alloc]init];
* 非自己生成的对象，自己也能持有。例如：NSMutableArray * __strong array = [NSMutableArray array];
* 不再需要自己持有对象时释放。
* 无法释放非自己持有的对象。

### 引用计数器
每一个OC对象都有一个属性，叫做retainCount，翻译过来也就是引用计数器，类型为unsigned long，占据8个字节，每一个对象负责维护对象所引用的记数值，当一个新的引用指向对象，那么这个对象的引用值增加1，当我们新创建出一个对象的时候这个对象的引用计数器的值默认为1，当这个对象被少一次引用的时候那么就先让这个对象的引用记数值减1，当这个对象所引用的记数值为0的时候，代表这个对象没有被使用，这时系统会自动回收掉此对象，回收这个对象的同时自动调用这个对象的dealloc方法

### 控制规则
* 为对象发送一条retain消息，那么对象的引用计数器的值就会+1
* 为对象发送一条release消息，那么对象的引用计数器的值就会-1
* 为对象发送一条retainCount消息，那么就可以得到这个对象的引用计数器的值 

#### 管理原则
* 谁创建，谁释放 ；

### 野指针
在C中，声明一个指针变量，没有为这个指针变量初始化，那么这个指针变量的值也就是一个垃圾值，指针指向随机的一块空间，那么我们叫做野指针

在OC中，一个指针指向的对象被释放了，那么这个指针叫野指针

### 对象的回收
对象所占用的字节空间，分配给别人使用，系统未分配这块空间被别人使用之前，这个对象的数据仍然处在内存中

### 僵尸对象
已经被收回，但是这个对象的数据仍然处在内存中，像这样的对象叫做僵尸对象；
僵尸对象有可能可以访问也有可能不可以访问，当僵尸对象所占的内存空间还没有分配给别人使用的时候，这个数据的对象其实仍然存在，通过指针仍然可以找到这个对象，所以说这个时候僵尸对象还可以被访问，当这个僵尸对象已经分配给别人使用的时候，这个对象就不存在了，这个时候不可以被访问

注意：一旦一个对象成为僵尸对象之后，这个对象无论如何都不应该被使用，无论有没有分配给别人使用，都不能用！且不可以复活！

### 避免内存泄漏
有对象的创建，就必须要匹配一个release，retain和release的次数要匹配，不要随便为一个指针赋值为nil，除非这个指针是野指针，在方法中不要随意对传入的对象进行retain

当我们通过野指针去访问僵尸对象的时候会报错，为了避免报错当一个指针成为野指针后，为这个指针赋值为nil

